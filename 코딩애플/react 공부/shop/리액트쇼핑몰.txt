* 리액트로 쇼핑몰 만들기

+ Bootstrap 라이브러리(html 자동으로 짜주는 라이브러리 / 라이브러리 사용법)
    - 개발 작업을 할 때 작업 시간과 피로를 덜어주는 프로그램이 라이브러리임.
    - html을 짜는건 시간이 오래 걸리는 작업이므로 "Bootstrap"이라는 라이브러리로 간단하게 html을 짜보려고 한다.
        * react에서 라이브러리 사용하는 방법
            - 사용할 라이브러리 사이트에 접속한다.
            - 라이브러리 사이트에서 해당 라이브러리를 설치하는 터미널 코드를 찾는다.
            - 해당 코드를 터미널에 입력하면 라이브러리가 다운로드 된다.


* react에서 html에 배경 이미지 삽입하기(import문)
    - 굳이 왜 하는진 모르겠지만 css를 안 쓰고 html에 배경이미지(backgroundImage)를 삽입하려면 import문을 사용해야 한다.
    - react에서 html에 이미지를 넣으려면 해당 태그에 style attribute를 달아야 한다.
        - ex) <div style = {{backgroundImage : '이미지 경로'}}></div>
    - 그런데 react에선 js 처럼 "url(경로)"를 넣어서 즉석으로 이미지 경로를 정할 수 없다.
    - jsx파일 특성인지 뭔진 모르겠지만 import문을 통해서 해당 이미지파일 경로를 저장한 후에 집어 넣어야 한다.
    - " import 작명 from '이미지경로' "이렇게 import 문으로 경로를 저장한 다음에 style attribute에 url() 언어를 'url(' 과 ')'으로 두 개로 분리해놓고 그 사이에 작명한 import문을 +로 연결시키면 된다.
        ex) <div style = {{backgroundImage : 'url(' + 작명 + ')' }}></div>
    - 솔직히 이미지 하나하나 넣는것도 너무 효율 떨어지고 복잡하고 가독성 엄청 떨어지는데 왜 html에 style을 넣으려는지는 모르겠다. 난 css파일에 style 만들거 같다. 그냥 "import '../App.css'" 이렇게 딸깍 한번 하면 끝 아닌가..
        * html 만들때 img태그 src 설정할 때도 import문을 사용해야 해서 어쩔수 없이 import문을 사용해야 할 거 같다.. 진짜 왜 이렇게 불편한 방식으로 만들었을까...

* 이미지 파일 등 저장은 public폴더에(import로 이미지 끌어와서 쓰는게 불편한 사람을 위해 준비한 public폴더)
    - 앞에 이미지 파일을 삽입하려면 import문을 사용하는 복잡한 절차를 밟아야 하고 수많은 이미지 파일들을 import로 불러오기도 부담스럽다.
    - public 폴더에 이미지를 저장하면 훨씬 간편하게 코드를 짤 수 있다.
    - src파일에 있는 파일들은 실제로 웹페이지 배포를 할 때 js, css, html이 압축이 되거나 파일명이 변해서(bundling이라고 한다.) 이미지 파일을 import문으로 만드는등 추가 작업을 해야 했다.
    - 하지만 public폴더 안에 있는 파일은 압축되지 않고 온전히 이름과 형태를 보존한다.
    - public폴더 안에 있는 자료를 끌어오고 싶을때 경로를 "/경로" 이렇게 경로 앞에 / 하나만 붙이면 끌어올 수 있다.
    - 하지만 이렇게 "/경로"를 이용해 만든 src경로는 서브페이지에 적용할때 오류가 발생한다.
    - main.com/어쩌구/ 가 주소인 사이트에 이미지 경로를 삽입 하려면 "/어쩌구/경로" 이렇게 수정해야 적용된다.
    - 하지만 수십개의 서브페이지에 어쩌구를 바꾸려면 너무 복잡해질 수 있어서 create react app 라이브러리 홈페이지에서 권장하는 경로코드를 이용해여 일관성 있게 경로를 만들 수 있다.
    - "<img src = {process.env.PUBLIC_URL + '/경로'}></img>" 이렇게 public경로 앞에 process.env.PUBLIC_URL 코드를 입력하면 자동으로 해당 페이지의 어쩌구 값을 입력시켜준다. 

* export / import 사용법(서버에서 변수, 함수 등 데이터 가져올떄)
    - 서버에서 업데이트 되는 파일을 가져와 홈페이지에 넣으려면 export / import 함수를 잘 알아야 한다.
    - export함수는 해당 js 안에 있는 변수, 함수 등을 다른 파일로 가져갈 수 있게 만드는 문법이다.
    - import함수는 다른 js파일 안에 있는 변수, 함수 등을 가져와서 사용할 수 있게 만드는 문법이다.
        * export / import 함수 사용법
            1. 하나의 변수를 전송하고 싶을때
            - export default "변수명" <- 이 코드를 입력하면 해당 js파일에 있는 변수를 옮길수 있는 상태로 만들어준다.
                * import "작명" from "./해당파일경로" <- 이 코드를 import 받을 파일에 작성하여 "작명"으로 변수처럼 사용 가능
            2. 하나 이상의 변수를 전송하고 싶을때
            - export {"변수명1", "변수명2" , "변수명 3"} <- 이 코드를 입력하면 해당 js파일에 있는 변수들을 클로저 안에 입력한 만큼 옳길수 있는 상태로 만들어준다.
                * import {"변수명1", "변수명2" , "변수명 3"} from "./해당경로파일" <- 이 코드를 import 받을 파일에 작성하면 클로저 안에 "변수명"으로 변수처럼 사용 가능
    - 물론 예시엔 변수명이라고만 적었지만 함수, 컴포넌트들도 가져올 수 있다.
    - import 해 온 자료듣은 state변수로 만들어 기존에 state를 사용하던 방식대로 사용하면 된다.

* router(라우터, react에서 서브페이지(상세페이지)를 만들고 싶을때 사용하는 라이브러리)
    - 웹페이지를 만들면서 메인페이지 이외에 서브페이지를 만드는 경우 일반 js는 새로 html을 만들어 서브페이지를 만든다.
    - js로 만들어진 html파일을 /서브파일명 을 입력하면 해당 주소로 접속해 html파일을 보여주는 형식임
    - react에선 페이지를 하나만 사용하며 그 페이지 안에서 페이지들을 교체하며 보여주는 형식을 가지고 있다 이를 SPA(single page application)라고 한다.
    - react에서 상세페이지를 나눌땐 메인 파일에 컴포넌트로 새로 서브페이지를 추가한 후
    - /작명 링크로 접속을 하면 메인 파일에서 해당 서브페이지 컴포넌트를 보여주는 형식임.
    - 라우터 기능은 기존 react에 라이브러리를 설치해서 사용하는 방식으로 "react-router-dom"이라는 라우터를 현재 대부분이 사용 중이다.
        * react-router-dom으로 라우터 사용하기
            - 우선 알아둬야 할 점은 라우터 라이브러리는 여러가지 사이트들이 있고 이 react-router-dom은 그 사이트들 중 하나를 사용하는것 뿐이니 굳이 외우려 하지 말고 그때그때 필요한 사이트에서 설명서를 보면서 라우터 라이브러리를 사용하면 된다.
                이것도 react-router-dom 사이트 들어가면 설명 그대로 있음.
            1. 터미널을 열어 "npm install react-router-dom@6"을 입력해 react-router-dom 6버전을 설치한다.
            2. index.js(app.js로 만든 html import 하는 파일?) 에 들어가 메인페이지 컴포넌트를(ex. <APP />) "<BrouserRouter></BrouserRouter>"라는 태그로 감싸주면 된다.
                ex) <BrowserRouter><APP /></BrowserRouter>
                    * BrowserRouter를 사용하면 index.js파일 위에 BrowserRouter을 react-router-dom으로 부터 가져온다는 import문이 형성된다.
            
            * 팁) import문을 사용할때, 내가 만든파일을 import 하려는 경우엔 파일경로 앞에 "./"을 붙여야 하고 다른 외부 사이트등에서 파일을 가져오려고 하는 경우엔 외부 사이트의 설명서를 따라 경로를 작성하는데 이곳엔 대부분 "./"을 넣지 않는다.
            
            3. App.js파일로 돌아와 import문법으로 router기능을 사용하는데 필요한 함수 "Routes, Route, link" 를 react-router-dom에서 가져온다.
                ex) import {Routes, Route, link} from "react-router-dom";
            4. 홈페이지에 나온 사용법처럼 App.js 파일 html에 들어가서 Routes, Route, link를 태그처럼 사용하여 라우터 기능을 구현하면 된다.
                ex) <Routes>
                        <Route path="/작명" element={HTML내용}></Route>
                        <Route path="/작명2" element={HTML내용}></Route>
                    </Routes>
                    * 여기서 path는 해당 링크에 추가로 "/작명"을 붙여주면 해당 element를 보여주는 용도로 사용된다.
            5. link태그를 이용하면 주소창을 수정해 페이지 이동 버튼을 만들 수 있다.
                ex) <link to="/">홈</link> == 홈 화면으로 이동
                    <link to="/detail">상세페이지</link> == 상세페이지 화면으로 이동
            6. App.js 안에 너무 많은 코드가 들어간다 싶으면 새로 js 파일을 하나 만들고 그 안에 서브 컴포넌트를 만든 후에 변수로 저장 후 export해서 App.js에 import시켜 라우팅 하면 된다.
                * 404페이지(주소를 잘못입력했을때 잘못입력했다 알려주는 페이지)만들기
                    - 주소를 잘못 쳐서 엉뚱한 페이지가 나왔음을 알려주는 페이지를 수동으로 만들 수 있다.
                        1. Route의 경로(path)설정을 할 때 "*"을 입력하면 기록된 경로 이외의 모든 것들을 칭하게 된다.
                        2. * 로 경로를 설정하고 element에 오류페이지라고 설명해주는 컴포넌트를 만들면 끝이다.
                            ex) <Route path="*" element={<div>잘못된 페이지입니다.(404)</div>}></Route>

* useNavigate / Outlet / Nested Routes(다양한 라우터 라이브러리 기능)
    * 이것도 import로 react-router-dom에서 명령어들을 가져와서 사용한다.
        1. useNavigate(페이지 이동을 도와주는 함수)
            - useNavigate는 앞서 보여준 라우터 기능인 Link기능을 대신 할 수 있다.
            - "let 작명 = useNavigate();" <- 이렇게 usestate처럼 변수로 useNavigate를 만든 후에 기능을 넣을 태그에 onClick이벤트리스너를 넣고 function함수를 만들어 그 안에 "작명(/이동할페이지경로)"를 입력하면 페이지 이동 기능이 구현된다.
                ex) <div onClick={() => {작명(/이동할페이지경로)}}></div>
            - 추가로 "작명(1)" / "작명(-1)" 등 useNavigate함수에 저런 숫자를 집어넣으면 양수 = 페이지 앞으로 가기 / 음수 = 페이지 뒤로 가기 의 기능으로 숫자만큼 반복된다.
        2. Nested Routes(페이지 안에 페이지 만들기) + Outlet(Nested Route 배출구)
            - 페이지 안에 거미줄처럼 연결되는 또 다른 페이지를 만들때 경로(path)를 "/페이지/페이지안에페이지" 이런식으로 줄줄이 이어서 만들수도 있다.
            - 하지만 다른 방식으로도 구현할 수 있다.
            - <Route path="/"></Route>문법을 div라고 생각하고 안에 자식 Route들을 집어넣으면(이 떄 서브페이지 경로엔 "/"을 붙이면 안된다.) 페이지 경로를 이어붙이는 효과를 보여준다.
                ex) <Route path="/서브페이지" element={}>
                        <Route path="서브서브페이지1" element={}></Route>  ==  "/서브페이지/서브서브페이지1"
                        <Route path="서브서브페이지2" element={}></Route>  ==  "/서브페이지/서브서브페이지2"
                    </Route>
            - 이렇게만 해서 끝난게 아닌게 서브서브페이지들을 서브페이지 안에서 보여주기 위해서는 서브페이지의 어느곳에서 보여줘야 할 지도 정해줘야 한다(안 정해주면 경로 입력해도 서브서브페이지 안 보여줌).
            - "<Outlet></Outlet>"이라는 태그를 만들면 해당 태그의 위치에서 서브서브페이지들을 보여줄 수 있게 된다.
                ex) 
                    function 서브페이지(){
                        <h4>서브페이지임</h4>
                        <Outlet></Outlet>      <== 저 공간 안에 "/서브페이지/서브서브페이지1"경로를 짜면 서브서브페이지1의 내용이 들어가게 된다.
                    }
    - 이런 식으로 페이지를 만들면 ui뒤로가기 버튼을 직접 구현할 수도 있고 UI스위치를 만들어 페이지 이동경험을 쉽게 만들어주는 등 이점들이 많다.

* URL파라미터(상세페이지 100개 만들때 쉽게 정리하기)
    - Route 안에 자식 Route요소를 넣어서 서브서브페이지를 만들 수 있지만 쇼핑몰에 여러가지 상품들의 상세페이지 같이 100개, 1000개의 서브페이지를 만드려고 한다면 jsx안에 코드를 너무 많이 써야 한다.
    - 이를 해결하기 위한 방법이 URL파라미터인데 사용 방법은 간단하다.
    - 서브페이지 주소 다음에 "/:작명(URL파리미터)"을 해주면 아무 문자나 입력해도 그 앞에 서브페이지 주소로 들어가게 되는 코드다.
        ex) <Route path = "/Detail/:word" element = {<div>123</div>}
            == 주소창에 "localhost123/Detail/아무런말" 이렇게 입력을 해도 Detail페이지가 출력되게 바뀐다.
    - 이렇게 "/:작명"으로 만든 서브페이지는 어떤 문자나 숫자를 입력해도 똑같은 페이지가 나온다.
    - 하지만 이 페이지에서 여러가지 상품을 보여주기 위해선 Detail페이지의 html이 유동적인 html이 되어야 한다.
    - Detail페이지에서 데이터를 state로 가져와서 상품 순서를 보여줄 수도 있겠지만 엄청 귀찮고 복잡할 것 같다.
    - "/:작명"을 사용했을때의 작명을 Detail로 가져오는 방법이 있는데 이 방법을 사용하면 훨씬 수월하게 할 수 있다.
    - "useParams()"이라는 함수를 사용하면 ":/작명(URL파라미터)"에서 작명했던 내용을 import해올 수 있다.
        ex) "localhost123/Detail/:1" 페이지에서 useParams()을 사용 == useParams()에는 1이 저장되었음.
    - 이를 함수로 만들어 let a = useParams();을 사용하면 작명했던 글자를 변수로 해당 페이지에서 사용할 수 있게 된다.

* find(object함수의 특정 한가지 값을 특정해서 object를 불러오는 방법)
    - 방금 같은 URL파라미터를 통해 여러개의 서브페이지를 만들수 있다.
    - 그런데 만약 메인페이지에서의 정렬된 html들이 이름정렬 등으로 인해 순서가 뒤죽박죽 섞이게 된다면 기존에 map함수 등으로 순서를 정해놓은 html들이 뒤죽박죽 섞여 상세페이지에서 보여주는 물건들도 전부 섞이게 될 수 있다.
    - 그래서 상세페이지를 유동적으로 만들때엔 array, object의 순서로 페이지를 만드는 것이 아닌 array, object 안에 만들어놓은 특정한 값(ex. id : 0)을 충족시키는 array, object를 보여주게 만들어야 한다.
    - arr.find(function(파라미터){파라미터.특정값 == 특정값의값})을 사용하면 해당 arr에서 특정한값의값을 가지고 있는 object내용을 가져올 수 있게 된다.
        ex) 
            arr = [
                {
                    id : 0,
                    product : a
                },
                {
                    id : 1,
                    product : b
                },
                {
                    id : 2
                    product : c
                }
            ]

            arr.find(function(a){a.id == 0})  

              ==>   {
                        id : 0,
                        product : a
                    }
                    
    - 이걸 사용하면 정렬기능을 사용하여 뒤죽박죽된 html에서 링크를 들어가도 해당 고유 값을 가지고 있는 object의 내용으로 이동하게 된다.

*styled-components(css파일 없이 css만들기 라이브러리)
    - "styled-components"라는 라이브러리가 있는데 이걸 사용하면 css파일 필요 없이 간편하게 css를 작성할 수 있다고 한다.
        * 설치방법
            1. 터미널에 "npm install styled-components"를 입력해 라이브러리를 설치한다. 
            2. 사용할 파일에 styled기능을 styled-components라이브러리에서 import해온다.
                ex) import styled from "styled-components"
            3. import한 파일 안에서 변수로 내가 원하는 스타일의 태그를 형성할 수 있는 "styled"문법을 사용 할 수 있게 된다.
                ex) let Yellowbtn = styled.button`
                                    backgroundcolor : yellow;
                                    color : black;
                                    padding : 10px;
                                    `
                * "styled.태그" 다음에 ``을 사용해야 클로저 처럼 스타일을 넣을 수 있게 해준다
            4. 변수로 만든 styled문법은 컴포넌트처럼 사용이 가능하다.
                ex) <Yellow>버튼</Yellow>
                    ==> styled에 작성했던 스타일 대로 버튼이 만들어진다.
        
    - styled-components의 장점
            - 다른 js파일들의 간섭 없이 style이 적용된다.
            - 무슨 말이냐면 css파일로 스타일을 만든게 있다면 그 파일의 내용이 모든 js파일에 적용되서 의도가 없었지만 class나 id가 똑같은 태그에 해당 css가 적용되는 불상사가 발생할 수 있다.
            - react가 파일을 배포하게 될 때 모든 파일들을 압축하기 때문이다(이를 bundling이라고 한다).
                * 하지만 styled기능 없이 한 가지 파일에만 css파일을 종속시킬 수 있는 방법이 있다.
                    - 해당파일.js
                      해당파일.module.css

                      이렇게 해당파일 다음에 ".module.css"를 붙이면 해당파일에 종속된 css가 된다.
            - css를 구동할때 해당 페이지 css만 구동 시키기 때문에 페이지 로드 속도가 향상된다.
            - 변수로 만든 css들은 "${props => props.작명}"으로 유동적으로 변경이 가능하다.
                ex) let Box = styled.div`
                    backgroundcolor : ${props => props.bg};
                    `
                    <Box bg="grey">상자임</Box>
                    ==> div태그에 회색배경이 깔린다.
            - 더욱 유동적인 styled를 만드려면 jsx에서의 if문인 " ? : "문을 사용하면 된다.
                ex) let Box = styled.div`
                    backgroundcolor : ${props => props.bg};
                    color : ${props => props.bg == "grey" ? "white" : "black"}
                    `
                    <Box bg="grey">상자임</Box>
                    ==> div태그에 회색배경이 깔리고 흰색 글자가 세겨진다.
                    <Box bg="yellow">상자임</Box>
                    ==> div태그에 노란색배경이 깔리고 검은색 글자가 세겨진다.
            - 추가로 기존의 스타일에서 새로 추가하는 스타일 태그를 만드려 할 때 기존 스타일을 복사 할 수 있는 기능도 있다.
                ex) let Newbox style.button(Box)`
                    fontSize : 10px;
                    `
                    => 기존의 Box컴포넌트의 스타일을 그대로 가져와주고 추가로 ``를 달아 수정할 수 있다.
                        * 직접 해보니깐 오류 생기고 안되는데 내가 잘못한건지 업데이트 돼서 지원을 안하는지 모르겠다.
        
    - styled-components의 단점
            - js파일이 매우 복잡해지고 가독성이 떨어짐
            - 다른 파일에서 해당 styled-component를 사용해야 하면 import로 가져와야 하는데 이러면 일반 css와 다를바 없음
            - 협업 할 때 css담당이 css외길인생을 달려왔으면 이런 해괴망측한 코드를 이해 못 할 수 있다.

    - styled-component 결론
            - 장점도 있고 단점도 있는 라이브러리라서 필수는 아니고 내가 css를 잘한다면 굳이 사용 안해도 괜찮다.
            - 협업시에 팀원들이 해당 라이브러리를 사용한다면 옆에서 아는척 하자.
        
* lifecycle과 useEffect(hook)
    * lifecycle이란
        - lifecycle는 컴포넌트의 생애를 표현하는 것과 같다.
            1. 컴포넌트가 페이지에 장착(형성)되는 것(mount)
            2. 컴포넌트가 업데이트(리렌더링?)되는 것(update)
            3. 컴포넌트가 페이지에서 제거되는 것(unmount)
    
    - 우리는 코드를 통해 컴포넌트의 lifecycle에 간섭할 수 있다.
    - 어떤 식이냐면 세 가지 생애주기에 갈고리를 달아 추가로 코드를 실행시키는 것이다.
    - 기존의 옛 react문법(class문법)에선 컴포넌트 클로저 안에 각각 
        componentidMount(){
            컴포넌트 mount시 이곳의 코드가 실행됨
        }
        componentidUpdate(){
            컴포넌트 update시 이곳의 코드가 실행됨
        }
        componentWillUnmount(){
            컴포넌트 unmount시 이곳의 코드가 실행됨
        }
        이런 코드들을 넣어서 훅(hook)으로 코드를 실행시켰다.
    - 요즘 react문법으로 컴포넌트에 훅을 달려면 "useEffect"을 사용하면 된다.
    - "useEffect(()=>{})"를 사용하면 페이지가 렌더링 된 이후에 useEffect 안에 있는 코드를 실행시키는 기능을 수행한다.
    - useEffect를 이용하면 계산이 오래 걸리는 연산자 기능 등을 페이지가 렌더링 된 후에 실행시켜 주기 때문에 필요한 구간에 코드를 넣을 수 있고, 페이지가 렌더링 되는 시간을 단축시켜주는 역할을 한다.
    - 왜 react 제작자가 이름을 useEffect로 지었는지 생각해보면 기존 js 기능에서 함수를 코딩할때 함수의 핵심기능 이외에 자잘한 기능들을 프로그래밍 용어로 "side effect"라고 부르는데 그것의 이름을 따 와서 지었다고 보면 된다.
    - 작명 의도대로 핵심기능을 제외한 자잘한 기능들을 담은 함수들을 따로 보관해 실행시키는 장소가 "useEffect"라고 생각하면 된다.
        ex) 오래걸리는 반복연산, 서버에서 데이터 가져오는 작업, 타이머 달기 등등

* Dependency array([], useEffect 실행조건 만들기)
    - useEffect문 클로저 뒤에 ", []"을 추가하면 추가로 실행조건을 넣을 수 있다.
        ex) useEffect=(()=>{}, [])
    - [](Dependency array / 디펜던시 어래이 / 의존 어래이) 안에 state변수를 집어넣으면 해당 state변수가 변할때만 useEffect 안에 있는 코드를 실행시켜준다(새로고침으로 리렌더링 하는 경우엔(Mount)useEffect 코드가 실행되는거 같다).
    - 이러면 [] 안에 존재하는 state 이외의 다른 state가 변경될때엔 해당 useEffect 코드가 실행되지 않는다.
    - 추가로 [] 안에 아무 state도 넣지 않는다면 오직 컴포넌트가 Mount 될 시에만 useEffect 코드가 실행되게 만들수 있다.

* useEffect 안에서 사용하는 return문
    - useEffect 클로저 안에 return문을 넣으면 return문 안에 있는 코드는 useEffect가 동작하기 전에 실행된다.
        ex)
            useEffect(()=>{
                대충 코드들 1
                return()=>{
                    대충 코드들 2
                }
            }, [])
            
            ==> 이러면 return문 안에 있는 코드들(대충 코드들 2)이 먼저 동작하게 된다.

    * 해당 return문은 주로 기존에 있던 코드들을 지우는 용도로 자주 사용된다.(clean up function 이라고 부름)
    - 주로 서버에서 데이터를 몇 초에 걸쳐서 가져오게 만들때 페이지를 리렌더링 하는 일이 많아지만 
      그 만큼 몇 초 후에 가져오는 데이터들이 계속 생가면서 페이지 오류가 발생할 수 있는데 그 때 return문에 "기존 데이터요청은 전부 지워주세요"라는 식의 코드를 짜서 오류를 방지하게 만든다.
    - clean up function은 특징이 하나 있는데 컴포넌트가 Mount 될 시엔 작동을 안하고 컴포넌트가 unMount할 시엔 작동을 한다.

* "replace(/ /g, "")"   <= input값을 가져올때 띄워쓰기 값을 모두 지우고 싶을때 사용하면 띄워쓰기를 전부 지워준다.

* Ajax(리액트로 서버와 통신하기)
    - 웹페이지를 만들때 제품 더보기 파일 등 그때그때 새로 업로드 해야하는 파일들은 대부분 서버에서 가져온다.
    - 서버에서 데이터를 가져오는 행위를 하려면 크게 2가지를 알아야 하는데 바로 "서버"와 "요청"이다.
    - "서버"란 간단하게 말하면 "부탁하면 진짜 들어주는 프로그램"이다.
        ex) youtube서버 == 동영상 요청하면 진짜로 동영상 보내주는 프로그램
            네이버웹툰서버 == 웹툰 요청하면 진짜로 웹툰 보내주는 프로그램
    - 그래서 서버를 개발할 때 짜는 코드는 "누가 A 요청하면 A 보여주세요"라는 코드로 작성한다.
    - 이렇게 서버에서 데이터를 요청하는 코드를 짤 때에는 세부적으로 코드를 잘 짜야 한다.
        1. 어떤 방법(get / post)으로 2. 어떤자료(url)를 적어보내라.
        * 내가 직접 만든 서버가 없으니 일딴 애플쌤이 만든 서버에서 데이터를 가져올거다.
    - ajax 문법을 사용하려면 3가지 중 1개를 선택해야 한다.
        1. 옛날문법(XMLHttpRequest)
        2. 요즘문법(fetch())
        3. axios같은 외부라이브러리
    - 이번엔 외부라이브러리를 이용해 볼 것이다.
        * axios 사용법
            1. 터미널을 열어 "npm install axios"를 입력해 axios를 설치한다.
            2. 사용할 파일에 "import axios from "axios""를 입력하여 기능을 추가시킨다.
            3. 사용할 기능(function)에 axios.get("서버주소")를 입력하면 서버랑 연결이 된다.
            4. 그 후에 "axios.get("서버주소").then((서버데이터파라미터)=>{})"로 "then"문법을 이용해 function기능을 만들면 then 파라미터 안에 서버 내용이 json파일로 저장된다.
            5. 파라미터 안에 저장된 내용을 데이터로 전환 시키려면 "서버데이터파라미터.data"를 입력하면 데이터 형태로 변환된다.
            6. 대부분의 리액트 작업에선 서버와 ajax를 이용해서 통신한다.
    
    * ajax요청이 실패했을때
        - 만약 인터넷이 끊기거나 오류로 인해 서버 요청이 실패할 경우에 서버전송이 실패됐음을 알리는 코드를 작성하는 방법이 있다.
        - ajax 코드의 끝에 ".catch(()=>{})"문법을 붙여 안에 코드를 작성하면 서버전송에 실패했을때 해당 코드가 작동하게 된다.

* post(ajax 서버로 데이터 보내기)
    - "get"문법으로 서버에서 데이터를 가져오는 것과 반대로 "post"문법을 사용하면 서버로 데이터를 보낼 수 있다.
    - "axios.post("서버주소", {"작명" : "내용"})"이렇게 코드를 만들면 해당 서버주소로 object에 담긴 내용을 보낼 수 있다.
    * 서버에서 데이터를 주고받을때 무조건 문자로 된 자료만 주고받을 수 있다(array, object형 자료 안 됨.)
        - 그래서 서버로 데이터를 전송할때엔 자료의 작명과 내용에 따옴표("")을 붙여야 데이터를 전송할 수 있다.
            ex) axios.post('https://codingapple1.github.io/shop/data3.json', "{"name" : "kim"}") 이것을 json이라고 부른다.
        - 반대로 우리가 서버에서 데이터를 받아올땐 서버에선 json이었던 파일을 axios라이브러리가 array / object파일로 변환해줘서 ".data"만 붙이면 바로 사용이 가능한 것이다.
        - 바닐라js로 받아오려면 추가 문법들을 사용해야한다.

* Promise.all()(동시에 데이터를 받고 싶을때)
    - 서버에서 여러 데이터를 한 번에 받고 싶으면 promise문법을 사용하면 된다.
    - "Promise.all([axios.get("서버주소1"), axios.get("서버주소2)])" 이렇게 promise.all 파라미터 안에 넣은 array에 가져올 서버주소들을 입력하면 한꺼번에 데이터를 가져올 수 있다.
    - 그 후엔 똑같이 .then()으로 문법을 이어나가면 된다.

* fetch(js에 기본적으로 있는 ajax문법) 사용시 json파일 변환시키는 법
    - js 기본문법 "fetch()"로 서버에서 데이터를 받아오려면 다음과 같이 문법을 짜면 된다.
    - "fetch("서버주소").then((파라미터) => 파라미터.json())" 또는 "fetch("서버주소").then(data => {})"를 사용하면 array나 object로 변환해준다고 한다.
    - 아직 안 써봤으니 나중에 한번 써보는 연습해보자.
    
* tab UI 만들어보기(동적인UI만들기)
    - 만드는 방법은 useState를 활용하면 js에서 동적인 UI 만들던 것 보다 훨씬 쉽게 만들 수 있다.
    - ui네비게이션 역할을 할 버튼들을 먼저 만들고 디자인한다. + ui페이지들을 디자인 한다.
    - ui네이게이션 버튼을 클릭할 때 값이 바뀌게 할 useState를 하나 만든다(트리거 역할)
        ex) let [trigger, settrigger] = useState(0)  <= 여기서 useState에 들어가는 값은 ui의 형태를 생각해서 자유롭게 만들면 된다.
    - ui네비게이션 버튼에 onClick 이벤트를 만들어 해당 버튼을 클릭하면 settirgger을 사용해 trigger state의 값을 변경시키게 만든다.
        ex) <button onClick={()=>{settrigger(1)}}>1</button>
    - {}(삼항연산자) 안에 ? :문을 넣거나, if문을 사용해 trigger의 값이 ~~일 때 특정 ui페이지를 보여주는 코드를 만들면 끝이다.
        ex) {
                trigger == 1 ? <div>1번 내용입니다.</div> : null
            }
    * if문 컴포넌트로 만들어서 사용하기
        - html 안에서 사용하지 못하는 if문을 컴포넌트로 만들어서 html안에 집어넣으면 동작을 한다.
            ex) 
                function if문컴포넌트화(){
                    if(trigger == 1){
                        return <div>1번 내용입니다.</div>
                    }
                }
        * 주의점으로 컴포넌트 안에 if문을 넣는거라 return을 꼭 넣어야 if문 안에 코드가 실행된다.
        * 추가로 메인 컴포넌트 바깥에 if문을 서브컴포넌트로 만들려면 props기능으로 trigger state를 가져오는 것을 잊어선 안된다.
            ex) <if문컴포넌트화 trigger = {trigger}/>           * html에 집어넣는 컴포넌트에 props전달할 변수 집어넣기!

                function if문컴포넌트화(props){                      * 컴포넌트 파라미터에 props넣고 state 사용!
                    if(props.trigger == 1){
                        return <div>1번 내용입니다.</div>
                    }
                }

* props팁
    - props로 데이터를 가져올 때 굳이 귀찬게 props.~~~로 코드를 작성할 필요 없다.
    - 컴포넌트 파라미터에 props 대신 가져오는 변수의 이름들을 {}(클로저)로 감싸면 변수명만 입력해서 값을 얻을 수 있다.
        ex) function if문컴포넌트({trigger, ~~}){                <== props. 없이 가능!
            if(trigger == 1){
                return <div>1번 내용입니다.</div>
            }
            console.log(~~)                                     <== props. 없이 가능!
        }

* transition(react 사용해면서 애니메이션 효과 넣기)
    - className을 통해 css로 애니메이션 효과를 넣으면 끝이다.
    - 그냥 html, css랑 똑같은 개념이다.(class만 className으로 바뀜)
    - 라고 생각했는데 애니에이션을 주기위해 className을 바꾸는 방식이 js랑 다르다.
    - 우선 useState를 통해서 className의 이름을 바꾸거나 추가하거나 삭제할 수 있다.
    - useState로 유동적인 className을 만들고 useEffect를 사용하여 훅기능을 통해 특정 부분이 실행될 때 className을 변경하면 애니메이션 작동 트리거를 만들 수 있다.
        ex) let [class, setclass] = useState('off')
            useEffect(()=>{
                setclass('on')
            }, [훅])
            * 최초 페이지 Mount시에만 useEffect를 작동시키려면 [](디펜던시 어래이)그대로 남겨놓으면 된다.
    * 유동적인 className 만들기
        - 유동적인 className 만드는 법은 다음과 같다.
            1. className={} 이렇게 "" 대신 클로저({})로 먼저 감싸고 그 안에 state나 className을 집어넣으면 된다.
            2. 두 개 이상의 className을 작성하고 싶으면 중간에 +를 집어넣거나 ``을 이용하면 된다.
                ex) className={변수 + 변수} / className={"className " + 변수} <= 주의사항으로 className 사이에 띄워쓰기를 집어넣어야 className이 붙지 않고 따로따로 적용된다.
                    className={`변수 변수`} / className={"className" + 변수} <= 이렇게 ``을 사용하면 className 끝이 띄워쓰기를 사용할 필요 없어 나는 이걸 더 추천한다.
        - useEffect에 return문과 setTimeOut함수를 이용해 className이 추가되고 사라지는 시간들을 조정하면 더욱 세밀한 애니메이션 작업을 할 수 있다.
            ex) useEffect(()=>{

                    setTimeout(()=>{
                        setclass('on')
                    }, 100)                         <= setTimeout함수로 0.1초 후에 class를 'on'으로 변경

                    return(
                        setclass('off')             <= return문으로 useEffect함수 작동시 제일 먼저 class를 'off'로 변경
                    )

                }, [])

* contextAPI(props 쓰기 싫을 때 사용하는 리액트 문법)
    - 리액트에서 state를 자식으로 전송하는 기능이 있다.
    - 그런데 자식의 자식에게 다이렉트로 state를 전송할 순 없다.
        ex) 부모 (state)
            자식        <= state전송 가능
            자식의 자식  <= state전송 불가능
    - 자식에게 먼저 state를 전송하고 그 자식의 state를 자식의 자식에게 주어야 전송이 가능하다.
    - 한 2개 정도 자식들이 있는 거라면 그나마 괜찮겠지만 자식들이 9개, 10개 이렇게 된다면 코드가 매우 복잡해질 거 같다.
    - 이를 해결하기 위한 리액트 기본문법이나 외부라이브러리가 있다.
        1. Context API(리액트 기본문법)
        2. Redux등 외부라이브러리
    1. Context API
        1. createContext()를 부모 컴포넌트가 있는 파일에 적으면 자동으로 react에서 context를 import 해오는 코드가 작성된다.
        2. 변수를 하나 만들어 createContext 컴포넌트를 하나 만들고 해당 파일 앞에 export를 붙여준다.(여기서 context는 쉽게 생각하면 state들을 담는 포장용기라고 생각하면 된다. + export를 붙여 사용할 자식 파일에 import해줄거임)
            ex) export let Context1 = createContext()     *컴포넌트로 만들거기 때문에 변수 앞글자가 대문자여야 한다.
        3. state를 전송받을 자식 컴포넌트를 만들어놓은 createContext컴포넌트로 감싼다.(컴포넌트 뒤에 .Provider을 붙여줘야 한다.)
            ex) 
                <Context1.Provider>
                    <Child/>
                </Context1.Provider>
        4. 감싼 context컴포넌트에 value={{}}를 붙여 안에 전송할 state들을 입력한다.
            ex) 
                <Context1.Provider value={{state1, state2}}>
                    <Child/>
                </Context1.Provider>
        5. 다 입력했으면 자식 컴포넌트 파일에 들어가 createContext()를 입력해 해당 파일에도 createContext기능을 react에서 import 해온다.
        6. "import {context1} from "./부모파일경로"를 입력해 export한 context1파일을 자식컴포넌트 파일로 import해온다.
        7. "let {state1, state2} = useContext(context1)" 이렇게 useContext를 이용해 context1안에 들어있는 state들을 풀고 let 변수 안에 클로저({})에 필요한 state들 이름을 입력하면 해당 state들이 변수로 저장되어 사용할 수 있게 된다.

        - 이렇게 context로 변수를 만들면 해당 자식요소 뿐 만 아니라 자식요소 전역에(자식의 모든 족보)해당 state를 사용할 수 있게 된다.
        - 하지만 Context API는 사용에 있어 비효율적인 측면이 있다.
            1. Context API는 결국 자식 컴포넌트에 전역으로 퍼지는 컴포넌트를 감싸는 것이라 해당 context를 사용하지 않는 자식요소까지 리랜더링을 시키게 된다.
            2. useContext를 사용하고 있는 컴포넌트를 다른 파일에서 재사용하게 될 때 Context를 import 하는게 귀찮아 질 수 있다
                (useContext를 쓰고있는 자식 컴포넌트를 부모 컴포넌트가 아니라 다른 자식 컴포넌트 파일에 집어넣으면 context가 작동이 안되는건가? 안해봐서 모름)
    
    * 그래서 이것보단 redux같은 외부라이브러리를 많이들 쓴다고 한다.

    2. redux라이브러리(+장바구니 페이지 만들기)
        1. pakage.json 파일로 들어가서 react-dom파일이 18.1.0버전 이상인지 확인한다.(이하 버전이면 redux설치가 안된다.)
        2. 터미널에 들어가서 "npm install @reduxjs/toolkit react-redux"를 입력해 redux를 설치한다.
        3. redux를 사용하기 위한 커멘더 파일이 하나 필요하므로 "store.js"파일을 하나 새로 만든다.(대부분 redux작업을 할 때 커멘드 파일을 store.js로 저장함.)
            * 해당 파일에 파일 전역에 퍼지는 state를 만들거임.
        4. 만든 store.js파일로 들어가서 redux에서 configureStore기능을 import 해온다.
            ex) import {configureStore} from "@reduxjs/toolkit"    <= redux페이지 경로는 @reduxjs/toolkit이다.
        5. store.js파일 최하단에 configureStore기능을 예시와 같이 export해준다.
            ex)
                export default configureStore({
                    reducer : {

                    }
                })
        6. index.js파일로 넘어와 BrouserRoute컴포넌트로 감싸져 있는 컴포넌트에 Provider컴포넌트로 감싸준다.
            ex) 
                <React.StrictMode>
                    <Provider>
                        <BrowserRouter>
                            <App />
                        </BrowserRouter>
                    </Provider>
                </React.StrictMode>
        7. Provider컴포넌트에 props 기능을 넣듯이 store변수를 집어넣어주면 초기설정이 완료된다.
            ex) 
                <React.StrictMode>
                    <Provider store={store}>
                        <BrowserRouter>
                            <App />
                        </BrowserRouter>
                    </Provider>
                </React.StrictMode>
            
            * store을 넣을때 파일에 store변수가 store.js파일에서 import되어야 사용이 가능한데 보통 Provider컴포넌트 안에 store변수를 넣으면 자동으로 코드가 작성되지만 제대로 작동이 되지 않는다면 한번 확인해보자.
                ex) 
                    import store from "./store"

    2-1. store 안에 컴포넌트 전역으로 사용할 state 만들기(Redux 실제 사용)
        * 이렇게만 하면 props를 만들 필요가 없다.

        1. store.js 파일에 "createSlice()"를 적어 Redux로 부터 createSlice 기능을 import 해온다.
            - createSlice({}) <= react에서 state와 비슷한 역할을 함.
        2. "createSlice({})" 이렇게 만든 후 클로저 안에 object처럼 "name : "state이름"" + "initialState : "값"" 이 두가지를 추가시키면 state 하나가 완성된다.(name == let 변수 역할, initialState == useState()에 들어가는 값 역할)
            ex) createSlice({
                    name : '~~~',
                    initialState : '~~~'
                })
        3. 다 만든 createSlice함수를 변수로 저장하여 state를 다른 컴포넌트에 전송할 준비를 한다.
            ex) let 변수1 = createSlice({
                    name : '~~~',
                    initialState : '~~~'
                })
                let 변수2 = createSlice({
                    name : '~~~',
                    initialState : '~~~'
                })
        4. store.js파일 하단에 만든 configureStore함수에 "작명 : 변수.reducer" 이렇게 코드를 작성하면 다른 컴포넌트로 state를 옮길 준비가 완전히 끝난다.
            ex) export default configureStore({
                reducer : {
                    작명 : 변수1.reducer,
                    작명2 : 변수2.reducer
                }
            })
        5. 원하는 컴포넌트 함수 파일에 들어가서 "useSelector((state=>{return state}))"을 사용하면 Redux store 안에 있는 state들을 가져와준다. 그리고 해당 함수를 변수로 저장하면 사용 준비가 끝난다.
            ex) 
                function 컴포넌트(){
                    let 작명 = useSelector((state=>{return state}))

                    return(
                        ~~~
                    )
                }
        6. 이렇게 변수로 저장한 useSelector기능은 object형식으로 state들이 저장되어서 object 형식대로 코드를 작성하면 state 값을 사용할 수 있다.
            ex)
                console.log(작명.user) == {user : 'kim'}
    
    2-2. Redux에서 state 변경하기
        - Redux에서 state를 수정하는 법은 다음과 같다.
            1. state를 수정해주는 함수를 만든다.
            2. 원할 때 그 함수를 실행해달라고 store.js에 요청한다.
        - Redux의 state변경 방식은 과정이 매우 복잡하고 귀찮은데 대신 버그가 터졌을때 디버깅 하는 과정에서 유용하기 때문에 어려워도 배워야 한다.
        
        * Redux에서 state변경하기 (reducers : {} / .action / useDispatch())
            1. store.js에 만들어놓은 createSlice함수에 "reducers : {}"를 추가한다.
            2. reducers 클로저 안에 state를 변경하는 함수를 직접 만든다.
                ex)
                    let user = createSlice(){
                        name : "user",
                        initialState : "kim",
                        reducers : {
                            이름변경1(() => 
                                return "john kim"
                            ),
                            이름변경2(() =>
                                return "kim sung"
                            )
                        }
                    }

                * 참고로 state를 변경하는 함수를 만들때 파라미터 안에 함수를 집어넣으면 해당 state의 기본값을 가져올 수 있다.
                    ex)
                        let user = createSlice(){
                            name : "user",
                            initialState : "kim",
                            reducers : {
                                이름변경1((state) => 
                                    return "john " + state         <= 이러면 state의 기본값이 "kim"이니 "john kim"으로 state가 변경된다.
                                ),
                                이름변경2((state) =>
                                    return state + " sung"         <= 이러면 state의 기본값이 "kim"이니 "sung kim"으로 state가 변경된다.
                                )
                            }
                        }
            3. store.js에 만든 함수를 export해야 다른 파일에서 state를 사용할 수 있어 export를 해줘야 한다.
                - 해당 state변경함수를 export하는 방법은 좀 특이하다.
                    1. createSlice()함수의 name 값 + .actions 이렇게 코드를 짜면 reducers : {}로 만든 모든 state변경 함수 값들이 그 자리에 출력되게 만든다.
                        ex) 
                            user.actions == ["john kim", "kim sung"]
                    2. 해당 코드를 변수로 저장해 변수 클로저 안에 필요한 함수명을 입력해놓으면 그 state변경값이 따로 저장된다.
                        ex)
                            let {이름변경1} = user.actions
                            console.log(이름변경1()) == "john kim"
                    3. 변수 전체를 export 하면 export할 준비가 끝난다.
                        ex)
                            export let {이름변경1, 이름변경2} = user.actions
            4. export가 끝났다면 state를 변경할 파일에 들어가 export한 변수를 import 해온다.
                ex)
                    import {이름변경1, 이름변경2} from "./../store.js"
            5. export해온 state변경함수를 사용하기 위해선 useDispatch()라는 함수를 감싸줘야 하기 때문에 useDispatch기능을 Redux에서 가져와 변수로 저장한다.
                ex)
                    import {useDispatch} from "react-redux"

                    let dispatch = useDispatch() 
                
                * useDispatch함수는 Redux의 기능을 사용하고 있는 본진에게 해당 기능을 실행해달라 요청해주는 역할을 한다.
                    ex) state변경함수를 사용하려고 하는데 해당 변경함수는 store.js의 createSlice()함수 안에 만들어져 있으니 store.js가 본진이라 할 수 있고 본진에게 해당 state변경 함수를 실행시켜달라 요청하게 되는 것이다.
            6. dispatch변수를 사용해 한번 감싸준 후 그 안에 state변경함수를 집어넣으면 store.js파일에게 state변경을 요청해 state가 변경된다.
                ex)
                    let a = useSelector((state) => state);

                    dispatch(이름변경1())

                    console.log(a.user) == "john kim"
        
        - 이렇게 state변경 함수를 만들면 이점이 있다.

            이점) 컴포넌트를 수백가지를 사용하고 있는 프로젝트에서 state가 이상한 값으로 변경이 되는 버그가 발생할 시 본진인 store.js만 오류를 체크하면 해결할 수 있다.
                - state들을 컴포넌트에서 직접 변경을 하는 것이 아닌 본진에서 변경하도록 요청하는 것이라 본진만 디버깅을 하면 된다.
    
    2-3. Redux state 변경시 state자료가 array나 object일 때
        - state가 array나 object일 경우 바꾸고 싶은 위치를 기존 array, object방식대로 추적해서 변경시키면 된다.
            ex)
                let obj = createSlice({
                    name : 'obj',
                    initialState : [
                        {name : "kim", count : 1},
                        {name : "park", count : 2}
                    ]
                    reducer : {
                        obj변경((state) => 
                            state[0].name = "john"
                        )
                    }
                })

                console.log(obj[0].name) == "john"
    
    2-4. Redux state변경함수 파라미터 활용법
        - Redux의 state변경함수에 파라미터는
            1. 첫번째 파라미터 함수를 만들면 그 함수는 변경하는 state의 기본값을 가진다.
                ex)
                    let ex = createSlice({
                        name : 'ex',
                        initialState : 1             <= state의 기본값 == 1
                        reducer : {
                            ex변경((a) =>            <= 파라미터 첫번째칸에 a 함수를 만들었음
                                a =+ 1               <= 첫번째 파라미터 안에 담긴 값은 state의 기본값이므로 a의 값은 1
                            )
                        }
                    })

                    다른 파일로 넘어옴

                    let a = useSelector(state => state)

                    dispatch(ex변경());

                    console.log(a.ex) == 2
                    
            
            2. 두번째 파라미터 함수를 만들면 그 함수는 유동적으로 값을 바꿀 수 있는 값이 된다.
                ex)
                    let ex = createSlice({
                        name : 'ex',
                        initialState : 1             
                        reducer : {
                            ex변경((a, i) => 
                                a =+ i               <= i가 두번째 파라미터에 담겼으므로 유동적으로 변하는 값이 됨
                            )
                        }
                    })

                    다른 파일로 넘어옴
                    
                    let a = useSelector(state => state)

                    dispatch(ex변경(5))              <= state변경함수 파라미터에 5를 집어넣어서 i의 값은 5가 된다.

                    console.log(a.ex) == 6

    * 리액트에서 자주쓰는 if문 작성패턴
        - jsx로 작성하는 html에서는 if문은 대체하기 위해서 삼항연산자(? :)을 사용해야 하지만 컴포넌트를 만들어 if문을 만든다면 jsx 안에서 if문을 사용할 수 있다.
            ex) 

                function Main(){
                    return(
                        <Component/>        <= 컴포넌트로 집어넣어서 if문 사용
                    )
                }

                function Component(){
                    if(true){
                        console.log("참")
                    }
                }
    
        - 가끔씩 이렇게 if문을 만들어서 사용하면 되게 편할 것 같은 상황이 종종 생기는데 실제로 리액트에서 자주쓰는 if문 예시 5가지를 준비했다.
            1. else 사용하지 않고 if문 만들기
                ex) 
                    fuction Component(){
                        if(true){
                            return <p>참이면 보여줄 HTML</p>
                        }
                        return null;
                    }
                
                - 이 방식은 if문이 한개인 경우에 코드를 축약하기 좋은 방식이다.
                - return문을 사용하면 그 아래에 있는 코드들은 실행을 중지하는 특성을 이용해 if문이 참이면
                  "<p>참이면 보여줄 HTML</p>"이 실행되고 밑에 코드부턴 사용이 중지되고 if문이 거짓이면 if문 아래에 있는 return문이 작동한다.
                - 이 방식은 else문과 똑같은 역할을 하기에 코드를 더 줄이고 싶을때 사용하면 된다.
            
            2. jsx 안에 삼항연산자 집어넣기(+ 삼항연산자도 else if 기능을 쓸 수 있다.)
                ex)
                    let a = true;
                    
                    function Main(){
                        return(
                            {
                                a == true ? console.log('참') : null
                            }
                        )
                    }
                
                - 이미 배워서 알겠지만 jsx에서 if문을 사용하려면 다음과 같이 표현하면 된다.
                - 그런데 else if 기능을 추가로 사용할 수 있는 방법이 또 있다.
                ex)
                    let a = false;
                    let b = true;
                    
                    function Main(){
                        return(
                            {
                                a == true ? console.log('참') : (b == true ? console.log('참') : null)
                            }
                        )
                    }
                - 이렇게 else문을 집어넣는 공간에 클로저()를 만들어 그 안에 다시 삼항연산자를 집어넣으면 else if와 동일한 기능을 수행한다.
                - 하지만 이렇게 코드를 짜면 가독성이 매우 떨어지니 웬만하면 if문을 컴포넌트로 사용하거나 코드를 하나 더 작성하는걸 추천함.
            
            3. &&연산자로 if 역할 대신하기
                - 연산자 중에 &&연산자가 있다.
                - 이 연산자의 특성은 코드를 차례대로 읽다가 중간에 하나라도 false값을 내는 코드를 찾으면 코드가 중단되는 특성을 가지고 있다.
                    ex)
                        true && console.log(1)    <= 1 출력됨
                        false && console.log(1)    <= 1 출력 안됨
                
                - 이런 특성을 이용해서 삼항연산자를 사용하지도, if문을 사용하지도 않고 똑같은 기능을 수행하는 코드를 만들 수 있다.
                ex)
                    let a = true;
                    
                    fucntion Main(){
                        return(
                            {a == true && <p>값 출력</p>}
                        )
                    }
                - 이런 코드는 if문이나 삼항연산자를 사용할 때 else의 값이 null일 경우에 더 축약된 코드를 대체하는 용도로 자주 쓰인다.

            4. switch / case 조건문
                - switch / case 문법은 참인지 구분할 대상이 하나밖에 없는 경우에 클로저{}를 줄일 용도로 사용하게 된다.
                    ex)
                        let a = 100;

                        switch(a){
                            case 1000 :
                                return console.log('거짓')
                            case 100 :
                                return console.log('참')
                            default :
                                return console.log('거짓')
                        }
                - 이렇게 사용하면 case는 if와 else if역할을 하고 default는 else의 역할을 한다.
                - 하지만 구분할 대상이 여럿인 문법에선(if(a == true && b == true){})사용할 수 없다.
            
            5. object / array 자료형 응용({}[])
                ex)
                    function Main(){
                        let [a, seta] = useState("info")

                        return(
                            <div>
                                {
                                    {
                                        info : <p>상품정보</p>,
                                        shipping : <p>배송관리</p>, 
                                        refund = <p>환불약관</p>
                                    }[a]
                                }
                            </div>
                        )
                    }
                - 다음과 같이 jsx에서 대괄호[]안에 담긴 state의 값에 따라 object 안에 들어가 있는 값을 보여주는 문법을 만들었다.
                - 이 문법을 사용하면 state의 값이 변하면 다른 html을 보여주는 문법을 만들때 매우 간결하고 직관적으로 문법을 만들수 있는 장점이 있다.
                - 이건 아마 state변경을 자주하는 react 하면서 많이 쓸 거 같다.
                * 변수에 object를 저장해서 컴포넌트 안에서 깔끔해 보이게 코드를 짤 수도 있다.
                    ex)
                        let 탭UI = {
                            info : <p>상품정보</p>,
                            shipping : <p>배송관리</p>, 
                            refund = <p>환불약관</p>
                        }

                        function Main(){
                            let [a, seta] = useState("info")

                            return(
                                <div>
                                    {
                                        탭UI[a]
                                    }
                                </div>
                            )
                        }
                    - 근데 이건 취향차이다.
    
    * local storage(로컬 저장소에 데이터 저장시키기)
        - 페이지를 새로고침하면 변경되었던 함수나 state들이 초기화 된다.
        - 사이트 재접속시에도 바꾼 정보들을 유지시키고 싶다면 데이터를 서버로 보내서 DB(데어터베이스)에 영구저장 하는 방법이 있다.
        - 하지만 서버도 모르고 DB도 잘 모르는 나는 일단 local storage에 저장해서 사용하는 법 부터 배워야 할 거 같다.
        - local storage는 데이터를 반영구적으로 저장할 수 있는 공간이다.
            * local storage의 위치는 개발자도구(f12) -> Application에 들어가면 나온다.
        - local storage 안엔 문자 데이터만 저장시킬 수 있으며, object처럼 key / value의 형태로 저장할 수 있다.
        - local storage에는 최대 5mb의 데이터를 저장할 수 있다.
        - 유저가 브라우저를 청소하는 일이 없으면 아무리 사이트를 재접속해도 데이터가 남아있는다.
            * 사용방법
                - localStorage.setitem('','')을 사용해서 ''안에 각각 key값, value값을 집어넣으면 local storage에 등록된다.
                - localStorage.getitem('')을 사용해서 ''안에 local storage에 저장해둔 key값을 입력하면 해당 value를 반환해준다.
                - localStorage.removeitem('')을 사용해서 ''안에 local storage에 저장해둔 key값을 입력하면 해당 값을 local storage에서 삭제시킨다.
                    * local storage를 수정하는 명령어는 없다. 그래서 데이터를 수정하려면 데이터를 꺼내서 수정하고 다시 집어넣어야 한다.
            * local storage에 array / object 집어넣기(+ json 사용법)
                - local storage엔 문자밖에 못 집어넣기 때문에 사실상 array / object를 담을 수 없다.
                - 하지만 데이터를 json형식으로 바꾸어 저장하면 사용할 수 있는 편법이 있다.
                - json형식은 object나 array 자료들의 값에 전부 따옴표('')을 붙이면 된다.
                    ex) {'name' : 'kim'}
                - JSON.stringfy()를 사용하면 ()안에 array나 object를 집어넣으면 json형태로 변환시켜준다.
                    ex) JSON.stringfy({name : 'kim'}) == {'name' : 'kim'}
                - JSON.parse()를 사용하면 ()안에 json문법을 넣으면 형식에 따라 array / object형태로 변환시켜준다.
                    ex) JSON.parse({'name' : 'kim'}) == {name : 'kim'}
                - 이렇게 json파일로 변환한 문자를 local storage에 저장해뒀다 parse문법으로 변환시켜 사용하면 된다.

    * session storage
        - session storage는 브라우저를 끄면 안에 있던 데이터들이 초기화 되는 저장공간이다.
            * 사용방법은 local storage와 동일하며 localStorage 대신 sessionStorage를 집어넣으면 된다.

    * new Set(중복배열 제거하기)
        - 애플쌤 만드신거 보니깐 new가 let같은 변수 역할인거 같다.
        - [...new Set(array나 object자료)] 이렇게 만들면 () 안에 유니크한 값들만 남기게 해서 중복되는 값들은 전부 제거되고 하나로 통일된다.
        - es6문법이라는데 이유는 잘 모르겠는데 저렇게 [...]으로 array를 한번 지웠다 다시 씌워야 하는거 같다.

    * redux-persist
        redux에서 제공하는 local storage 기능인데 한번 검색해보셈
    
* redux와 비슷하지만 더 쉬운 라이브러리
    1. jotai
    2. zustand
        - 그런데 취업 더 빨리 하고 싶으면 redux떡칠된 포트폴리오를 만들것

* react-query(실시간 데이터가 중요한 상황이라면 사용할 라이브러리 리액트쿼리)
    - ajax로 서버에서 데이터를 불러오면 여러가지 실시간 반응 기능들을 생각해볼 수 있다.(코인 거래사이트 등)
        ex) ajax 성공 / 실패시 html 보여주기, 몇초마다 자동으로 ajax요청하기, 실패시 몇초 후 요청재시도 하기, prefetch 등등
    - 이런 실시간 반응 기능들을 조금 더 쉽게 사용하고 싶을때 react-query 라이브러리를 사용하면 좋다.
    - "npm install react-query"를 터미널에 입력하면 설치가 된다. 
        * react-query 초기 세팅하기
            - react-query를 설치했으면 index.js에 들어가 "const queryClient = new QueryClient()"이렇게 입력해 quertClient 기능을 react-query에서 가져와 변수로 저장한다.(QueryClient()만 입력해도 가져와짐)
            - 추가로 "QueryClientProvider"을 입력해 react-query에서 QueryClientProvider기능을 가져온다.
            - index.js안에 있는 <App/>컴포넌트 위에 <QueryClientProvider/>컴포넌트를 감싸고 client attr에 QueryClient 변수를 집어넣는다.
                ex)
                    const queryClient = new QueryClient()


                    <QueryClientProvider client = {queryClient}>
                        <App/>
                    </QueryClientProvider>

        * react-query 사용법
            - 초기설정을 다 끝냈으면 axios등으로 데이터를 불러올 때 해당 axios코드를 useQuery란 함수로 한번 감싸면 된다(App파일에 속성부여 한다고 생각하면 편함).
                ex)
                    useQuery('작명',()=>
                        axios.get('https://codingapple1.github.io/userdata.json').then((a)=>
                            JSON.parse(a.data)
                        )
                    )
            - useQuery안에 만든 ajax파일을 변수로 저장해서 사용하면 된다.
                ex)
                    let result = useQuery('작명',()=>
                        axios.get('https://codingapple1.github.io/userdata.json').then((a)=>
                            JSON.parse(a.data)
                        )
                    )
        
        * react-query 장점
            1. ajax요청이 성공했는지 실패했는지 로딩중인지 react-query문법을 통해 쉽게 파악이 가능하다.
                ex)
                    let result = useQuery('작명',()=>
                        axios.get('https://codingapple1.github.io/userdata.json').then((a)=>
                            JSON.parse(a.data)
                        )
                    )

                    result.data             == ajax가 연결성공 했을때 들어오는 데이터
                    result.isLoading        == ajax가 로딩중일때 true 값을 가져옴
                    result.errot            == ajax가 연결실패 했을때 true 값을 가져옴
            
            2. react-query로 ajax요청을 하면 틈만 나면 자동으로 재요청(refetch)을 해줌
                ex)
                    let reactquery = useQuery('작명', ()=>
                        axios.get('https://codingapple1.github.io/userdata.json').then((a)=>
                            console.log('요청됨'),
                        )
                    )
                    ==> 이러면 요청됨 이라는 글자가 다른 창(vscode등)에 들어갔다 다시 홈페이지로 들어오면 콘솔창에 재입력이 된다.
                        직접 한번 해보셈
                
                +) 재요청(refetch)의 시간을 조정하는 문법도 있다(staleTime)
                    ex)
                       let reactquery = useQuery('작명', ()=>
                            axios.get('https://codingapple1.github.io/userdata.json').then((a)=>
                                console.log('요청됨'),
                            ),
                            {staleTime : 2000}
                        )
                        ==> 이러면 reactquery 요청이 완료되고 2초 동안 다른창을 들어갔다 나와도 refetch가 되지 않는다.
            
            3. 요청 실패시 retry를 자동으로 해줌

            4. state 공유를 안해도 된다.
                - 데이터 가져온 것을 props로 넘길 필요없이 props할 컴포넌트 파일에 똑같이 ajax요청하는 코드를 똑같이 또 적으면 된다.
                - react-query는 똑똑해서 ajax요청이 2개나 있으면 1개만 날려주고 캐싱기능이 있기 때문에 이미 같은 ajax요청을 한 적이 있으면 그걸 우선 가져와서 써준다.
                
            
            5. 서버를 요청한 후 5분 사이에 ajax 결과를 캐싱할 수 있다.
                ex) 
                    12:10분에 get요청을 함
                    12:13분에 다시 get요청을 함
                    ==> react-query가 12:10분 결과를 우선 보여주고 그 다음 get요청함(기존 성공결과를 먼저 보여줬다 재요청한 데이터를 새로 보여줌)
            
        * react-quert 한줄평
            - 기존 ajax로 데이터 가져오는건 그대론데 react-query를 덧붙여 추가적인 기능을 사용할 수 있는 라이브러리(실시간 업데이트 등등)
        
        * react-query 유사 라이브러리
            - redux-toolkit에 RTK Query도 유사한 역할을 함수
            - 아무튼 이런 유용한 라이브러리들 많으니 필요하면 구글링 해서 사용법이랑 찾아보자.

    * 개발자도구(React Developer Tools) & lazy import(개발 성능개선1)
        1. 개발자도구(React Developer Tools)
            - 코딩을 하다보면 여러가지 버그가 터지는데 에디터(vscode등)를 다시 살펴보는 방법도 있지만 개발자도구를 이용하여 찾으면 더 빨리 버그를 찾아낼 수도 있다.
            - 그런데 react로 개발을 하다보면 기존 html로 코딩하는 것과 달리 jsx로 작업하기 때문에 element의 어느부분을 수정해야 할 지 헷갈리는 경우가 많이 생긴다.
            - 이를 위해 chrome의 개발자 확장도구에서 "React Developer Tools"라는 react 전용 개발자 앱이 있다.
                * Components
                    - 이 확장도구를 다운받으면 개발자도구에 Components라는 항목이 추가되는데 react페이지 내의 elements를 mousehover 하는 것으로 확인이 가능하고 해당 element나 component안에 어떤 state / Effect / props들이 들어가 있는지 확인할 수도 있다.
                    - 추가로 state들을 해당 페이지에서 수정해볼 수도 있다.
                        ex) state들 안에 값이 [1, 2, 3]이었으면 [2, 2, 3]으로 즉각 수정해서 디버깅 해볼수도 있다.
                    - 그리고 우측의 "<>"아이콘은 클릭하면 해당 컴포넌트가 어느 공간에 적혀있는 코드인지 추적해서 Sources에서 보여준다(이게 젤 좋은듯).
                * Profiler
                    - 또 개발자도구에 Profiler이라는 항목도 추가되는데 이 항목은 성능저하되는 component들의 문제점을 찾아주는 역할을 한다.
                    - Profile항목 좌측 상단에 보면 녹화버튼이 있는데 이 녹화버튼을 누르고 페이지를 사용후 녹화버튼을 다시 누르면 사용했던 컴포넌트들의 렌더링 시간을 확인할 수 있다.
                    - 보통 1억번 연산시키는 코드 같은 극단적인 코드를 만들지 않는 이상은 렌더링 시간은 빠른 편이니 굳이 Profiler을 사용할 필요는 없다.
                    - 그냥 개발하다 체감상 렌더링이 오래 걸린다 싶으면 확인해보면 된다.
                    - 대부분의 웹페이지에서의 지연시간은 ajax요청(서버통신)이 오래 걸려서 발생하는 것임.
            
            * Redux DevTools
                - React Developer Tools 말고도 redux를 디버깅하는 Redux DevTools도 있음 == redux를 더 편하게 관리하고 싶으면 해당 개발자 도구도 다운받으면 된다.
                - Redux DevTools를 다운받으면 redux항목이 추가되는데 여기서 store.js에서 state가 변경되는 내역을 실시간으로 알려주는 기능을 한다.
                - 웹페이지에서 버튼을 클릭하여 state가 변경되는 등의 기능이 작동하면 변경된 기록이 redux항목에 추가가 된다.
        
        2. lazy import(필요해질때 import해오게 만드는 코드)
            - SPA(Single Page Application)은 페이지 배포시 모든 파일은 하나의 js파일로 압축하는데 이러면 페이지를 실행시킬때 페이지 다운로드 때문에 로딩속도가 느려지는 문제점이 발생한다.
            - 그래서 아직 필요하지 않은 컴포넌트들은 import해오지 않는 방법이 있는데 그게 바로 lazy 기능이다.
                * lazy import 사용법
                    - 기존의 import에 lazy function으로 감싸고 경로를 from대신 ()괄호로 감싸면 된다.
                        ex)
                            const Detailpage = lazy(()=>import('./routes/Detail.js'))
                    - 그 후에 해당페이지를 연결시켜주는 routes를 "Suspense"컴포넌트로 감싸주면 끝이다(Suspense 컴포넌트는 페이지를 다운받을때 해당페이지가 로딩되는 동안의 빈 공간을 형성시키는 역할을 해준다?)
                        ex) 
                            <Suspense fallback={<div>로딩중</div>}>    
                                <Routes>
                                    <Route path="/Detail/:pagenum" element={
                                        <Detailpage/>
                                    }   
                                    ></Route>
                                </Routes>
                            </Suspense>

                        * Suspense컴포넌트에 fallback attr을 붙이면 로딩중 페이지를 만들수 있다.
        
    * memo / useMemo(자식 컴포넌트 재렌더링 막기 / 개발 성능향상2)
        1. memo
            - 컴포넌트는 state등의 값이 변경되면 리렌더링이 되는 특성이 있다.
            - 그런데 부모컴포넌트가 리렌더링 되는 일이 발생하면 자식 컴포넌트들도 리렌더링이 실행된다.
            - 이러면 자식요소중에 크기가 큰 컴포넌트가 있을경우 웹페이지 성능저하의 원인이 될 수 있다.
            - 그래서 이를 해결하기 위해 해당 컴포넌트는 꼭 필요한 경우가 아닌 경우엔 리렌더링을 막는 기능이 memo다.
            - 리렌더링을 막을 컴포넌트를 memo()로 한번 감싸고 변수로 저장해서 사용하면 기존의 컴포넌트처럼 사용할 수 있을 뿐더러 부모요소의 리렌더링 때문에 컴포넌트가 리렌더링 되는것을 막아준다.
                ex)
                    let Child = memo(
                        function(()=>{
                            return(
                                ~~~~
                            )
                        })
                    )

            * memo란?
                - memo의 동작원리는 해당 컴포넌트의 props가 변할 때만 리렌더링 해주는 것이다.
                - 그래서 memo를 사용하려면 기존props와 신규props가 같은지 계속 비교해봐야 한다.
                - 그러니 막 남용하면 나중에 코드 건들기 복잡해질 수 있다.
                - 꼭 필요한 무거운 컴포넌트가 있으면 그 떄 쓰자

        2. useMemo            
            - useMemo는 useEffect와 거의 동일한 기능을 한다.
            - useMemo에 들어간 코드가 리렌더링이 되면 실행할건지 특정 컴포넌트가 리렌더링이 되면 실행할지 페이지 접속할때 한번만 렌더링 할 것인지
            - 이 둘의 차이는 시점뿐이다. useEffect는 페이지가 렌더링이 다 된 후에 발생하지만 useMemo는 페이지가 렌더링이 될 때 발생한다.
        
        * memo, useMemo는 실제 페이지를 만들때 너무 무거운 연산자가 들어갈 일이 거의 없기 때문에 필요할때만 찾아봐서 공부하는걸 추천한다.

    * batching개념 / useTransition / useDeferredValue(개발 성능향상3 / 느린동작 컴포넌트들 속도 향상시키기)

        * batching기능
            - 리액트에서 state변화가 일어날때마다 재랜더링이 발생한다.
            - 그런데 한번에 여러개의 state변화가 일어날땐 마지막 state에서 1번만 랜더링이 발생한다.
            - 이것을 batch라고 한다.
            - 하지만 ajax / setTimeout같은 늦게 동작하는 문법의 내부에선 state가 하나하나 변경될 때 마다 랜더링이 발생한다. == batching이 발생하지 않는다.
            - 그런데 최신리액트(18버전 이후)부터는 이런 문법 안에서도 batching이 작동하게 바뀌었다.
            - 리액트 최신버전 깔아라(?)
        
        * useTransition / useDeferredValue기능(Testing.js파일에서 실험함.)
            - useTransition을 사용하면 setTimeout / ajax같이 늦게 작동하는 컴포넌트들의 성능향상이 가능하다.
                * 카드비 돌려받기와 비슷한 원리라고 한다(?)
            - 가끔씩 한번애 수많은 state변경을 해야할 경우에 batching기능이 해당 state값들을 모두 변경시킨 후에 작동을 해야해서 UI동작이 느려지는 경우가 있다.
                ex) input에 타이핑을 치면 해당 내용을 기록하는 state가 10000번 발동한 후에 input안의 내용이 변경된다.(Testing.js참조)
            - 이는 사용자들에게 아주 불편한 경험을 유발하게 되서 반드시 최적화를 해야 한다.
            - useTransition은 state의 batching 순서를 바꿔주는 역할을 한다.
            - state가 변경될때 바로 batching을 실행해 먼저 state값이 한번 변한값을 반환하고 그 뒤에 해당 state를 10000번 발동하게 만들어준다.
            - 이를 통해 중요한 값을 보여주는 작업을 먼저 보여주고 그 뒤에 따라오는 무거운 작업들을 수행시켜 사용자가 체감하기에 훨씬 더 빠른 경험을 보여준다.
                * 하지만 batching을 먼저 보여주는것 뿐이지 전체적인 작업속도는 똑같기 때문에 가능한 여러 페이지로 쪼개서 데이터들을 분산시켜주는게 훨 좋은 방법이다.
            - 추가로 useTransition의 첫번째 변수은 해당 useTransition작업이 발생하고 있을때 true값을 출력하는 특성을 가진 변수여서 작업이 진행중임을 알리는 UI기능을 추가로 만들수도 있다.
                ex)
                    let [text, settext] = useState('')
                    let million = new Array(10000).fill(0)
                    let [isPending, startTransition] = useTransition()

                    const test=
                    function(){
                        return(
                            <div>
                                <input onChange={(e)=>{settext(e.target.value)}}></input>
                                {
                                    isPending ? <div>로딩중입니다.</div> : 
                                    startTransition(()=>{
                                        million.map(()=>{
                                            return <div>{text}</div>
                                        })
                                    })
                                }
                            </div>
                        )
                    }
                    - 이렇게 삼항연산자로 isPending함수가 true일때 로딩중입니다 라는 div를 출력하게 만들 수 있다.
                
                - useDeferredValue도 먼저 batching기능을 수행시켜주는 역할을 한다(하지만 로딩중 기능은 못 만든다).
                    ex)
                        let [text, settext] = useState('')
                        let million = new Array(10000).fill(0)
                        let state = useDeferredValue(text)

                    const test=
                    function(){
                        return(
                            <div>
                                <input onChange={(e)=>{settext(e.target.value)}}></input>
                                {
                                    isPending ? <div>로딩중입니다.</div> : 
                                    million.map(()=>{
                                        return <div>{state}</div>
                                    })
                                }
                            </div>
                        )
                    }
                    - 변경이 발생하는 state에 useDeferredValue를 덧씌워 새로운 변수로 저장하기만 하면 useTransition역할과 동일한 작업을 수행한다.
    
    * PWA(웹페이지를 모바일페이지처럼 만들기)
        - 웹사이트를 돌아다니다 보면 가끔씩 앱을 설치하겠냐는 팝업창이 뜰 때가 있다.
        - PC면 바탕화면에 모바일이면 앱보관소에 저장이 되는데 이를 사용해보면 웹페이지가 아닌 어플리케이션처럼 페이지가 운영되는것 같아보인다.
        - 사실 이 팝업은 웹사이트 바로가기 버튼을 설치해주는 것이지만 작동되는 방식이 모바일 앱 같아서 착각할 수 있다.
        - 이는 PWA(ProgressiveWebApp)이라고 칭하는데 웹사이트를 모바일앱 처럼 사용할 수 있게 만드는 기능이다.
            * PWA 장점
                1. 설치 마케팅 비용 적음(거의 10분의 1수준)
                2. 소비를 주도하는 연령층인 4~50대 아날로그유저들이 사용하기 편하다.
                3. html, css, js만으로 앱까지 개발할 수 있다.
                4. 푸시알림, 센서등의 앱이 제공하는 기능들을 앱브라우저기능을 통해 사용할 수도 있다.
    
    * PWA사용법
        - PWA가 가능한 리액트를 만들때 이미 만들어진 리액트 페이지에 PWA 기능을 추가시키는건 불가능하다.
        - 새로 리액트 파일을 만드는데 형성시킬 리액트 폴더 터미널에 "npx create-react-app 프로젝트명 --template cra-template-pwa" 이렇게 입력해주면 새로운 PWA리액트 페이지를 만들어준다.
        - 만약 기존에 만든 리액트페이지에 PWA기능을 넣고 싶다면 새로 PWA페이지를 만든 후에 기존 리액트 페이지와 설치한 라이브러리들을 복붙해서 만드는 방법도 있다.
            * PWA 개발 조건
                * PWA파일로 리액트를 만들었다면 기본적으로 만들어져 있다.

                1. manifest.json 파일이 있어야 함(public폴더에)
                        * manifest.json 파일은 리액트 사이트의 앱 제목 / 사진 / 배경색 / 디스플레이 형식 등의 어플리케이션 UI를 수정할 수 있는 기능을 한다.
                2. service-worker.js 파일이 있어야 함(build폴더에)
                    - 우선적으로 serviceworker.js파일을 생성시키려면 index.js파일에서 "serviceWorkerRegistration.unregister();"이런 코드를 찾을 수 있는데 해당 코드의 unregister을 register로 바꿔주면 service-worker.js파일을 사용할 수 있게 된다.
                        ex)
                            serviceWorkerRegistration.unregister();
                            == > serviceWorkerRegistration.register();
                    - 하지만 service-worker.js파일이 어디있는지 보면 src폴더에 있는데 여기에 있는 service-worker.js 파일은 설정용 파일이고 진짜 파일은 build라는 파일 안에 들어있다.
                    - index.js안에 unregister을 수정해서 생겨난 service-worker.js파일은 build 파일에 존재하는데 이는 터미널에 명령어를 입력하지 않으면 보이지 않는다.
                    - vscode터미널에 "npm run build"를 입력하면 build파일을 html / css / js파일로 변환시켜 에디터(vscode) 안에 보여주어 파일 안에 들어있는 service-worker.js 파일을 확일할 수 있다.
                        * service-worker.js파일은 모바일 앱처럼 오프라인에서도 웹사이트를 열 수 있게 만들어주는 역할을 한다.
                            - 모바일앱 처럼 웹페이지 구동에 필요한 모든 파일들을 미리 하드에 저장시킬 수 있기 때문이다.(이를 캐싱이라고 함)
        - 개발조건까지 충족시키고 build폴더에 index.html파일이 있는데 페이지를 배포하거나 live server 익스텐션등을 설치해 해당 웹페이지를 열면 해당 웹페이지를 설치할 수 있는 팝업창이 뜬다.
            * 설치버튼 강제로 열기 기능도 있다고 함(필요하면 찾아보셈)
    * 개발자도구 Application(PWA가 잘 작동하는지 확인 / 캐시 확인법)
        - PWA가 잘 작동되는지 확인하고 싶으면 개발자도구에 Application에 들어가면 Menifest, Service-Workers파일들이 잘 작동하고 있는지 확인할 수 있다.
        - 그리고 Application에서는 Cache Storage가 있는데 해당 저장소에서 내 어떤 파일들이 캐싱되고 있는지를 확인할 수 있다.

    * react-scripts(캐싱하고싶지 않은 파일들 걸러내기)
        - PWA페이지를 만들면서 내가 캐싱하고 싶지 않은 파일들을 걸러내는 방법이 있다.
        - vscode에 "node_modules" -> "react-scripts" -> config -> webpack.config.js파일을 들어가서 ctrl + F 후 inhectManifest를 입력해 해당 코드를 찾아 아래 exclude 코드에 내가 캐싱에서 제외하고 싶은 파일 이름을 예시에서 보여주는 형식처럼 입력하면 캐싱대상에서 제외시킬 수 있다.
            ex)
                * index.html파일을 캐싱에서 제외하고 싶다.

                new WorkboxWebPackPlugin.InjectManifest({
                    ~~~~~~
                    exclude: [/index\.html/]
                })
        - 그런데 보통 건드릴 필요 없다.
    
    * async(state 사용할때 주의할점, 동기 / 비동기 처리 방식이란)
        - 자바스크립트는 일반적인 코드를 작성하면 synchronous(동기 처리 방식)으로 처리된다고 한다.
        - 여기서 synchronous( 처리 )이란 코드 적은 순서대로 위에서 아래로 한줄한줄 실행되는 방식을 말한다.
        - 거의 모든 프로그래밍 언어들은 이 synchronous( 처리 )으로 작동된다.
            ex)
                console.log(1)
                console.log(2)
                console.log(3)

                ==

                1
                2
                3
        - 그런데 자바스크립트에선 특정 함수를 사용하면 asynchronous(비동기 처리 방식)으로 코드실행이 된다.
        - ajax, 이벤트리스너, setTimeout등이 특정 함수에 해당한다.
        - 이런 함수들은 처리시간이 오래 걸리기 때문에 코드를 순차적으로 진행시키지 않고 처리시간이 빠른 다른 코드들을 먼저 순차적으로 실행한 후에 함수 안에 코드를 실행시킨다.
            ex)
                console.log(1)
                axios로 서버에서 데이터를 get한 후에 클로저 안에 console.log(2)를 찍어주세요~
                console.log(3)

                ==

                1
                3
                2
        
        - 심지어 ajax가 0.00초 걸리는 코드라 해도 해당 함수들은 물리적으로 잠깐 처리가 보류되도록 설정되어있어 ansychronous( 처리 )으로 실행되게 되어있다.

    * react의 setState함수 특징(ansynchronous)
        - react에서 state의 값을 변경하는 setState함수는 ansychronous(비동기 처리 방식)으로 실행된다.
        - 이는 장점이 될 수도 있지만 sync형식으로 코드를 실행시켜야 하는 경우엔 의도치 않은 문제를 일으킬 수 있다.
            ex)
                let [count, setcount] = useState(0)
                let [age, setage] = useState(20)

                function App(){
                    return(
                        <div>
                            <div>안녕하십니까 전 {age}</div>
                            <button onClick={()=>{
                                setcount(count + 1);
                                if(count <  3){
                                    setage(age + 1);
                                }
                            }}>누르면한살먹기</button>
                        </div>
                    )
                }
            - 다음과 같이 count의 값이 3이하일때 age의 값을 1 증가시켜주는 코드를 만들면
              순차적으로 코드를 실행하는 구조라면 다음과 같이 작동될 것이다.
                * count == 1 => if문 조건 충족, age == 21
                  count == 2 => if문 조건 충족, age == 22
                  count == 3 => if문 조건 불충족, age == 22
            
            - 이렇게 age의 값이 22에서 멈춰야 한다. 그런데 state는 async형식으로 처리되기 때문에 조금 다른결과가 나온다.
                * if문 조건 충족, age == 21 / count == 1
                  if문 조건 충족, age == 22 / count == 2
                  if문 조건 충족, age == 23 / count == 3

                - 실제로는 다음과 같은 코드처럼 실행되어 age가 23까지 증가하게 된다.
                - 그 이유는 setcount문법은 async(비동기)처리이기 때문에 코드가 보류되었지만 if문은 sync(동기)처리이기 때문에 먼저 안에 있는 코드가 실행되었기 때문이다.
        
        - 이런 async방식을 sync처럼 이용하기 위해선 useEffect로 state함수가 변경되는 시점에 코드를 실행시키는 방법이 있다.
            ex)
                let [count, setcount] = useState(0)
                let [age, setage] = useState(20)
                useEffect(()=>{
                    if(count !== 0 && count <  3){
                        setage(age + 1);
                    }
                }, [count])

                function App(){
                    return(
                        <div>
                            <div>안녕하십니까 전 {age}</div>
                            <button onClick={()=>{
                                setcount(count + 1);
                            }}>누르면한살먹기</button>
                        </div>
                    )
                }
            - 이렇게 click이벤트리스너에 if문을 넣지 않고 useEffect에 if문을 집어넣으면 click이벤트리스너로 setcount의 값이 변경하고 useEffect가 count문이 변경된 것을 확인하고 if문을 실행시켜주기 때문에 if문이 실행되기 전에 setcount가 먼저 작동되어 sync처럼 코드를 실행시킬 수 있다.
            - 정확히는 sync방식처럼 실행시키는게 아니라 내가 의도한 대로 코드를 실행시키는 방식이다.
            - useEffect를 사용한다고 state함수가 sync방식으로 변하는게 아닌 내가 원하는 순서에 작동시키게 하는 방식이니
    
    * Node+Express 서버와 react 연동시키는법(서버와 리액트 연동시키기)
        * 서버란?
            - 유저가 데이터를 요청하면 보내주는 공간들을 일컽는 말
        * 웹서버란?
            - 유저가 웹문서를 요청했을때 해당 웹문서(html파일)를 보내주는 공간들을 일컽는 말
        - react나 Svelt 등의 라이브러리로 만든 파일들은 결국엔 html을 해당 라이브러리들로 예쁘게 꾸며놓은 것에 불과하기 떄문에 html로 문서화 시켜서 유저에게 배포시키면 react연동이 끝이 나는 것이다.

        * nodejs로 서버 만드는 법
            1. nodejs검색해서 설치
            2. 작업폴더 만들고 에디터로 오픈
            3. server.js 만들어서 코드 복붙
            4. 에디터 터미널 열어서 npm init -y 입력
            5. npm install express도 입력
            6. 다 완료했으면 server.js파일에 다음과 같이 코드 짜기
                ex)
                    const express = require('express')
                    const app = express()
                    const path = require('path')

                    app.listen(8080, function(){
                        console.log('listening on 8080')
                    })

        * 서버 배포하기 전에 작업물 html파일로 만드는 법
            - 내 작업물을 서버에 배포하려면 작업물들을 html파일로 만들어야 하는데 build를 해야 html 파일이 나온다.
            - 작업물 에디터에 "npm run build"를 입력하면 build 폴더를 생성하고 그 안에 html, css, js파일이 생성된다.
            - 그 중에 html파일은 index.html 하나만 생성되는데 이는 react로 만든 SPA(SinglePageApplication)이기 때문이다.
        
        * nodejs와 react 합치는 법
            - 이제 build로 만든 html파일을 server.js파일에서 "유저가 메인페이지로 접속하면 리액트로 build한 index.html파일을 보내줘라"라는 내용의 코드를 만들면 리액트와 Nodejs서버 합치기 끝이다.
            
